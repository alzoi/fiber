# API

## `RunScheduler`

Вызов функции `RunScheduler` разворачивает _планировщик_ (_scheduler_) и запускает в нем файбер, который исполняет переданную функцию:


```cpp
RunScheduler([]() {
  std::cout << "I'm fiber!" << std::endl;
});
```

Планировщик поддерживает очередь (_run queue_) готовых исполняться файберов.
На каждой итерации цикла планирования он извлекает файбер из головы этой очереди и запускает его. Запущенный файбер исполняется до тех пор, пока либо не завершит исполнение своей функции, либо добровольно не отдаст управление (например, вызвав `Yield` ).

Вызов `RunScheduler` – блокирующий, он завершается тогда, когда планировщик исчерпает работу, т.е. когда завершится последний файбер.

## `Yield`

Вызов `self::Yield()` снимает бегущий файбер с "процессора" и помещает его в хвост очереди планировщика. Управление возвращается планировщику, и тот переходит к следующей итерации цикла планирования.

## `Spawn`

Функция `Spawn` создает новый файбер и помещает его в хвост очереди планировщика.

Сам по себе вызов функции `Spawn` не приводит к передаче управления и моментальному исполнению нового файбера: новый файбер лишь планируется на исполнение, а управление остается у файбера, который вызвал `Spawn`.

```cpp
bool started = false;
JoinHandle h = Spawn([&]() {
  started = true;
  // ...
});
assert(!started);
```

### `JoinHandle`

Вызов `Spawn` возвращает объект `JoinHandle`, ассоциированный с запущенным файбером.
С помощью `JoinHandle` можно структурировать работу родительского / дочернего файбера.

#### `Join`

Блокирует файбер, вызвавший `Join`, до тех пор, пока не завершится файбер, с которым ассоциирован данный `JoinHandle`:

```cpp
JoinHandle child = Spawn([]() {
  // ...
});
child.Join();  // Дожидаемся завершения запущенного файбера, отдаем управление
```

#### `Detach`

"Отвязывает" экземпляр `JoinHandle` от ассоциированного с ним файбера, последний отправляется в "свободное плавание".

Методы `Join` и `Detach` – взаимоисключающие, вызвать можно только один из них и только один раз.

Пользователь обязан вызвать или `Join` или `Detach`.

## Синхронизация

- `Mutex`
- `CondVar`